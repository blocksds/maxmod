# DS Programming Guide

Here is a guide to step through the basics of installation/usage in a DS
project. This tutorial will assume that you are using one of the templates of
BlocksDS.

## Linking

Firstly, **libmm9** must be added to your library references. Add **-lmm9** to
the **LIBS** in your makefile like this:

```make
LIBS    := -lmm9 -lnds9
```

Next, you need to tell the makefile to make a soundbank file for you. What is a
soundbank file? It's a file that contains all the samples and modules for your
project!

Add a new directory to your project; I'll call it "audio". Then, set the
variable `AUDIODIR` to point to that folder:

```make
AUDIODIRS :=  audio
```

The Makefile will look for all `.mod`, `.s3m`, `.xm`, `.it` and `.wav` files in
that folder and generate a soundbank from it.

If you're using NitroFS in your project, the soundbank will be stored in the
NitroFS filesystem. If not, it will be added to the ARM9 binary as data, and it
will be available in memory from the start.

Keeping it in memory means that you won't be able to use that memory for
anything else! If you're making a very small game, that's okay. If not, by
keeping the soundbank in the filesystem, Maxmod will only load the parts that
are required for the songs and audio efects that you're playing right in that
moment, leaving more RAM available for you to use however you want.

## Setup

Now it's time to initialize Maxmod. **maxmod9.h** has the definitions for the
ARM9 side, include it in your source files. Also, include the generated
soundbank header too.

```c
#include <maxmod9.h>    // Maxmod definitions for ARM9
#include "soundbank.h"  // Soundbank definitions
```

There are multiple ways of setting up Maxmod to fit your needs. The easiest way
is to use the **mmInitDefault()** or **mmInitDefaultMem()** functions.
**mmInitDefault()** is used when your soundbank is in the filesystem,
**mmInitDefaultMem()** is used when your soundbank is loaded into memory (as
described above).

```c
void main(void)
{
    // Use this if you have the soundbank loaded into memory
    mmInitDefaultMem((mm_addr)soundbank_bin);

    // OR, use this if you have it in the filesystem
    //mmInitDefault("nitro:/soundbank.bin");
}
```

## Playing Music

Let's have a look at the soundbank header generated by the Maxmod Utiltiy.

```c
#define SFX_BLASTER     0
#define SFX_PHASER      1
#define SFX_BONK        2
#define MOD_TITLE       0
#define MOD_INGAME      1
#define MOD_CREDITS     2
#define MOD_ONEMORESONG 3
#define MSL_NSONGS      4
#define MSL_NSAMPS      156
#define MSL_BANKSIZE    160
```

Definitions prefixed by **MOD_** are module IDs. Definitions prefixed by
**SFX_** are sample IDs. **MSL_NSONGS** is the total number of modules in the
soundbank, **MSL_NSAMPS** is the total number of samples, and **MSL_BANKSIZE**
is the total number of modules plus samples (useful for alternate setup
process).

Before playing a song, the song must be loaded into memory. Use **mmLoad()** to
load songs into memory (or acknowledge their existence in memory).

```c
mmLoad(MOD_TITLE);
```

Now that **MOD_TITLE** is loaded. You may begin playing it with **mmStart()**.

```c
mmStart(MOD_TITLE, MM_PLAY_LOOP);
```

There are two modes for playback: **MM_PLAY_ONCE** and **MM_PLAY_LOOP**. If
**MM_PLAY_ONCE** is used, then the module will stop playing after it finishes
the last pattern. If **MM_PLAY_LOOP** is used, then the module will start
playing again from its restart position if it reaches the end.

When you are finished with a module, unload it from memory with **mmUnload()**.

```c
mmUnload(MOD_TITLE);
```

## Sound Effects

To load a sound effect into memory, use **mmLoadEffect()**.

```c
mmLoadEffect(SFX_BLASTER);
```

Now it can be played with **mmEffect()**.

```c
// Play a sound at its default frequency
mmEffect(SFX_BLASTER);
```

**mmEffectEx()** is a more flexible version of **mmEffect()**. It will let you
specify all of the attributes for the sound.

```c
// Play sound at half playback rate, 200/255 volume, and center panning
mm_sound_effect sound;
sound.id      = SFX_BLASTER; // Sample ID (make sure it is loaded)
sound.rate    = 0x400/2;     // Playback rate, 1024 = original sound
sound.handle  = 0;           // 0 = allocate new handle
sound.volume  = 200;         // 200/255 volume level
sound.panning = 128;         // Centered panning

mmEffectEx(&sound);
```

Both **mmEffect()** and **mmEffectEx()** return a sound effect handle that can
be used later to modify the sound.

```c
mysound = mmEffect(SFX_BLASTER);

// Change pitch to +1 octave
mmEffectRate(mysound, 1024 * 2);

// Change volume to half level (128 / 255)
mmEffectVolume(mysound, 128);

// Change panning to far-right
mmEffectPanning(mysound, 255);
```

If the effect isn't so important, you can mark it for *interruption*. This means
it can be overridden by music and other effects (if there are no other channels
available).

```c
// Allow effect to be interrupted
mmEffectRelease(mysound);
```

You can stop a sound effect like this:

```c
// Stop sound effect
mmEffectCancel(mysound);
```

When you are done using a sound effect, you can unload it from memory with
**mmUnloadEffect()**.

```c
// Unload sound from memory
mmUnloadEffect(SFX_BLASTER);
```

## Closing

For a better understanding, please have a look at the source code for the DS
examples.
